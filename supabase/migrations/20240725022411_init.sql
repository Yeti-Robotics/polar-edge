create type public.app_permission as enum ('admin.access', 'standform.submit');

create type public.app_role as enum ('admin', 'yeti-member', 'external');

-- PROFILES
create table public.profiles (
    id uuid not null references auth.users on delete cascade,
    primary key (id)
);

-- USER ROLES
create table public.user_roles (
    id bigint generated by default as identity primary key,
    user_id uuid references public.profiles on delete cascade not null,
    role app_role not null,
    unique (user_id, role)
);


create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin
  insert into public.profiles (id) values (new.id);
  insert into public.user_roles (user_id, role) values (new.id, 'external');
  return new;
end;
$$;

create trigger on_auth_user_created
after
insert
    on auth.users for each row execute procedure public.handle_new_user();

comment on table public.user_roles is 'Application roles for each user';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);

comment on table public.role_permissions is 'Application permissions for each role';

-- ACCESS CLAIMS IN RLS
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
begin
  -- Fetch user role once and store it to reduce number of calls
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
  into bind_permissions;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

alter table public.profiles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.user_roles enable row level security;

create policy "Allow logged-in read access" on public.profiles for insert with check ( auth.role() = 'authenticated' );
create policy "Allow individual update access" on public.profiles for update using ( auth.uid() = id );
create policy "Allow admin role access" on public.user_roles for all using ( (SELECT authorize('admin.access')));

